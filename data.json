{
    "Tuần 1": {
        "Bai1": {
            "Code": "function sumArray(input) {\n  let inputArray = input.split(\"\\n\");\n  let n = parseInt(inputArray[0]);\n  let arr = inputArray[1].split(\" \").map(Number);\n  return arr.reduce((a, b) => a + b, 0);\n}",
            "Problem": "Problem: Week 1 - Sum Array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Compute the sum Q of elements of this sequence.\n\nInput\nLine 1: contains n (1 <= n <= 1000000)\nLine 2: contains a1, a2, ..., an (-10000 <= ai <= 10000)\n\nOutput\nWrite the value of Q\n\nExample\n\nInput\n4\n3 2 5 4\n\nOutput\n14"
        },
        "Bai2": {
            "Problem": "Problem: Week 1 - List sequence of integer having 3 digits divisible by n\n\nDescription\nGiven a positive integer n, find all integer having 3 digits which is divisible by n.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 999)\n\nOutput\nWrite the sequence of numbers found (elements are separated by a SPACE character)\n\nExample\nInput \n200\n\nOutput \n200 400 600 800",
            "Code": "function listSequencOfInteger(input) {\n    let n = parseInt(input);\n    const arr = [];\n    let i = 100;\n    while (i < 1000) {\n        if ( i%n === 0 ) {\n            arr.push(i);\n        }\n        i++;\n    }\n    return arr.join(\" \");\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 1 - So s\u00e1nh ch\u00eanh l\u1ec7ch gi\u00e1 \u0111i\u1ec7n theo \u0111\u1ec1 xu\u1ea5t m\u1edbi c\u1ee7a EVN\n\nDescription\nHi\u1ec7n t\u1ea1i gi\u00e1 \u0111i\u1ec7n \u0111ang \u0111\u01b0\u1ee3c t\u00ednh theo b\u1eadc thang g\u1ed3m 6 m\u1ee9c (m\u1ee9c \u0111i\u1ec1u ch\u1ec9nh t\u1eeb 04/05/2023), v\u1edbi gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) l\u00e0 1.728VND v\u00e0 gi\u00e1 b\u1eadc cao nh\u1ea5t l\u00e0 3.015 VND. Tuy nhi\u00ean EVN \u0111ang \u0111\u1ec1 xu\u1ea5t m\u1ed9t c\u00e1ch t\u00ednh gi\u00e1 \u0111i\u1ec7n b\u1eadc thang m\u1edbi ch\u1ec9 g\u1ed3m 5 m\u1ee9c nh\u01b0 hinh d\u01b0\u1edbi, gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) kho\u1ea3ng 1.728 \u0111\u1ed3ng m\u1ed9t kWh v\u00e0 cao nh\u1ea5t (b\u1eadc 5) l\u00e0 3.457 \u0111\u1ed3ng m\u1ed9t kWh. \n\nB\u1eadc\tBi\u1ec3u gi\u00e1 hi\u1ec7n h\u00e0nh\tPh\u01b0\u01a1ng \u00e1n 5 b\u1eadc\n  \tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1 (*)\tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1\n1\t0-50 kWh\t1.728\t0-100 kWh\t1.728\n2\t51-100 kWh\t1.786\t101-200 kWh\t2.074\n3\t101-200 kWh\t2.074\t201-400 kWh\t2.612\n4\t201-300 kWh\t2.612\t401-700 kWh\t3.111\n5\t301-400 kWh\t2.919\t701 kWh tr\u1edf l\u00ean\t3.457\n6  \t401 kWh tr\u1edf l\u00ean\t3.015\t\t\n(*) Gi\u00e1 ch\u01b0a bao g\u1ed3m thu\u1ebf VAT\n\nH\u00e3y x\u00e2y d\u1ef1ng ch\u01b0\u01a1ng tr\u00ecnh nh\u1eadp v\u00e0o s\u1ed1 kwh \u0111i\u1ec7n c\u1ee7a m\u1ed9t h\u1ed9 ti\u00eau th\u1ee5 v\u00e0 so s\u00e1nh xem theo b\u1ea3ng gi\u00e1 m\u1edbi \u0111ang l\u1ea5y \u00fd ki\u1ebfn th\u00ec ti\u1ec1n \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 \u0111\u00f3 s\u1ebd t\u0103ng th\u00eam hay gi\u1ea3m \u0111i bao nhi\u00eau.\n\nINPUT: l\u00e0 s\u1ed1 kwh \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 (l\u00e0 s\u1ed1 nguy\u00ean)\nOUTPUT: l\u00e0 ch\u00eanh l\u1ec7ch gi\u1eefa gi\u00e1 theo \u0111\u1ec1 xu\u1ea5t v\u00e0 gi\u00e1 theo m\u00f4 h\u00ecnh b\u1eadc thang 6 m\u1ee9c \u0111ang \u0111\u01b0\u1ee3c \u00e1p d\u1ee5ng.\n\nVAT s\u1ebd \u0111\u01b0\u1ee3c l\u1ea5y l\u00e0 10%, v\u00e0 k\u1ebft qu\u1ea3 in ra s\u1ebd l\u1ea5y t\u1edbi 2 ch\u1eef s\u1ed1 th\u1eadp ph\u00e2n\n\nEXAMPLE \nINPUT\n540\nOUTPUT\n-22176.00\n\n\nINPUT\n70\nOUTPUT\n-1276.00",
            "Code": "function electricityPrices(input) {\n    let kwh = parseInt(input);\n    if (kwh < 0) return null;\n    let current_cost = 0;\n    const current_price = [1728, 1786, 2074, 2612, 2919, 3015];\n    const current_level = [50, 50, 100, 100, 100]\n    const current_amount = []\n    for (let i = 0; i < current_level.length; i++) {\n        current_amount[i] = current_level[i] * current_price[i];\n    }\n    if (kwh > 400) {\n        current_cost = current_amount[4] + current_amount[3] + current_amount[2] + current_amount[1] + current_amount[0] + current_price[5]*(kwh - 400);\n    } else if (kwh > 300) {\n        current_cost = current_amount[3] + current_amount[2] + current_amount[1] + current_amount[0] + current_price[4]*(kwh - 300);\n    } else if (kwh > 200) {\n        current_cost = current_amount[2] + current_amount[1] + current_amount[0] + current_price[3]*(kwh - 200);\n    } else if (kwh > 100) {\n        current_cost = current_amount[1] + current_amount[0] + current_price[2]*(kwh - 100);\n    } else if (kwh > 50) {\n        current_cost = current_amount[0] + current_price[1]*(kwh - 50);\n    } else {\n        current_cost = current_price[0]*kwh;\n    }\n    \n    let suggested_cost = 0;\n    const suggested_price = [1728, 2074, 2612, 3111, 3457];\n    const suggested_level = [100, 100, 200, 300]\n    const suggested_amount = []\n    for (let i = 0; i < suggested_level.length; i++) {\n        suggested_amount[i] = suggested_level[i] * suggested_price[i];\n    }\n    if (kwh > 700) {\n        suggested_cost = suggested_amount[3] + suggested_amount[2] + suggested_amount[1] + suggested_amount[0] + suggested_price[4]*(kwh - 700);\n    } else if (kwh > 400) {\n        suggested_cost = suggested_amount[2] + suggested_amount[1] + suggested_amount[0] + suggested_price[3]*(kwh - 400);\n    } else if (kwh > 200) {\n        suggested_cost = suggested_amount[1] + suggested_amount[0] + suggested_price[2]*(kwh - 200);\n    } else if (kwh > 100) {\n        suggested_cost = suggested_amount[0] + suggested_price[1]*(kwh - 100);\n    } else {\n        suggested_cost = suggested_price[0]*kwh;\n    }\n\n    let diff = 1.1 * (suggested_cost - current_cost);\n    return diff.toFixed(2);\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 1 - Convert a TEXT to Upper-Case\n\nDescription\nGiven a TEXT, write a program that converts the TEXT to upper-case. \n\nInput\nThe TEXT\n\nOutput\nThe TEXT in which characters are converted into upper-case\n\nExample \nInput \nHello John,\nHow are you?\n\nBye,\n\nOutput \nHELLO JOHN,\nHOW ARE YOU?\n\nBYE, ",
            "Code": "function upperCase(input) {\n    return input.toUpperCase();\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 1 - Extract Year, Month, Date from a String YYYY-MM-DD\n\nDescription\nGiven a date which is a string under the format YYYY-MM-DD (in which YYYY is the year, MM is the month (the month \u00ed from 1 to 12), and DD is the date (the date is from 1 to 31)). Extract the year, month and date.\n\nInput\nLine 1: contains a string s  \nOutput\nif s is not under the format YYYY-MM-DD, then write INCORRECT. Otherwise, write year, month, and date separated by a SPACE character\n\nExample\nInput\n2023-10-04\nOutput\n2023 10 4\n\n\nInput\n2023-10-4\nOutput\nINCORRECT \n\nInput\n2023-10 04\nOutput\nINCORRECT\n",
            "Code": "function extractYearMonthDay(line) {\n    let status = 1;\n    let check = '-';\n    let subStrings = [];\n    let subString = '';\n    let count = 0;\n    for (let c of line) {\n        if (c === check) {\n            subStrings.push(subString);\n            subString = '';\n            count++;\n        } else {\n            subString += c;\n        }\n    }\n    subStrings.push(subString);\n    if (count !== 2) {\n        return \"INCORRECT\";\n    } else {\n        for (let str of subStrings) {\n            if (str.length < 2) {\n                status = 0;\n                break;\n            }\n            for (let c of str) {\n                if (isNaN(c)) {\n                    status = 0;\n                    break;\n                }\n            }\n        }\n        let year = parseInt(subStrings[0]);\n        let month = parseInt(subStrings[1]);\n        let day = parseInt(subStrings[2]);\n        if (month < 1 || month > 12 || day < 1 || day > new Date(year, month, 0).getDate()) {\n            status = 0;\n        }\n        if (status === 0) {\n            return \"INCORRECT\";\n        } else {\n            return year + \" \" + month + \" \" + day;\n        }\n    }\n}"
        },
        "Bai6": {
            "Problem": "Problem: Week 1 - List all numbers from 1 to n and its squares\n\nDescription\nGiven an integer n, print numbers from 1 to n and its squares.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100)\nOutput\nEach line i (i = 1,...,n): contains i and i^2 (elements are separated by one SPACE character)\n\nExample\nInput\n3\nOutput\n1 1\n2 4\n3 9",
            "Code": "function listNumbersAndSquares(input) {\n    let n = parseInt(input);\n    const arr = [];\n    for (let i = 1; i <= n; i++) {\n        arr[i-1] = `${i} ${i*i}`;\n    }\n    return arr.join('\\n');\n}\n"
        },
        "Bai7": {
            "Problem": "Problem: Week 1 - Count odd and even number from a sequence\n\nDescription\nGiven a sequence of integer a1, a2, ..., an. Count the number of odd elements and even elements of the sequence.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100000)\nLine 2: contains a1, a2, ..., an. (1 <= ai <= 1000000)\nOutput\nWrite the number of odd elements and the number of even elements (separated by a SPACE character)\n\nExample \nInput \n6\n2 3 4 3 7 1\nOutput \n4 2",
            "Code": "function countOddAndEven(input) {\n  let inputArray = input.split(\"\\n\");\n  let n = parseInt(inputArray[0]);\n  let a = inputArray[1].split(\" \").map(Number);\n  let oddCount = 0;\n  let evenCount = 0;\n  for (let i = 0; i < n; i++) {\n    if (a[i] % 2 == 0) {\n        evenCount++;\n    } else {\n        oddCount++;\n    }\n}\nreturn oddCount + \" \" + evenCount;\n}"
        },
        "Bai8": {
            "Problem": "Problem: Week 1 - Add Subtract Multiplication Division of A and B\n\nDescription\nGiven 2 integers a and b. Compute a+b, a-b, a*b, a/b.\n\nInput\nLine 1 contains 2 integers a and b (1 <= a,b <= 1000)\nOutput\nWrite a+b, a-b, a*b, a/b  (4 integers are separated by a SPACE characters)\n\nExample\nInput\n9 4\n\nOutput \n13 5 36 2",
            "Code": "function addSubtractMultiplicationDivision(input) {\n    let array = input.split(' ');\n    let a = parseInt(array[0]);\n    let b = parseInt(array[1])\n    const arr = [a+b, a-b, a*b, parseInt(a/b)];\n    return arr.join(' ');\n}"
        },
        "Bai9": {
            "Problem": "Problem: Week 1 - Convert hh:mm:ss to seconds\n\nDescription\nGiven a time moment which is a string under the format hh:mm:ss (in which hh (0 <= hh <= 23) is the hour, mm (0 <= mm <= 59) is the minute, and ss (0 <= ss <= 59) is the second). Convert this time moment in seconds (result = hh*3600 + mm*60 + ss).\n\nInput\nLine 1: contains a string s representing the time moment.  \nOutput\nif s is not under the format hh:mm:ss, then write INCORRECT. Otherwise, write value converted.\n\nExample\nInput\n13:05:26\n\nOutput\n47126\n\n\nInput\n13:05:6\n\nOutput\nINCORRECT \n\nInput\n13:05 26\n\nOutput\nINCORRECT",
            "Code": "function convertToSeconds(timeString) {\n    let status = 1;\n    let check = ':';\n    let subStrings = [];\n    let subString = '';\n    let count = 0;\n    for (let c of timeString) {\n        if (c === check) {\n            subStrings.push(subString);\n            subString = '';\n            count++;\n        } else {\n            subString += c;\n        }\n    }\n    subStrings.push(subString);\n    if (count !== 2) {\n        return \"INCORRECT\";\n    } else {\n        for (let str of subStrings) {\n            if (str.length !== 2) {\n                status = 0;\n                break;\n            }\n            for (let c of subString) {\n                if (isNaN(c)) {\n                    status = 0;\n                    break;\n                }\n            }\n        }\n        let hour = parseInt(subStrings[0]);\n        let minutes = parseInt(subStrings[1]);\n        let second = parseInt(subStrings[2]);\n        if (hour < 0 || hour > 23 || minutes < 0 || minutes > 59 || second < 0 || second > 59) {\n            status = 0;\n        }\n        if (status === 0) {\n            return \"INCORRECT\";\n        } else {\n            return hour*3600 + minutes*60 + second;\n        }\n    }\n}"
        },
        "Bai10": {
            "Problem": "Problem: Week 1 - Solve degree-2 polynomial equation\n\nDescription\nGiven an equation ax^2 + bx + c = 0. Find solution to the given equation.\n\nInput\nLine 1 contains 3 integers a, b, c \nOutput\nWrite NO SOLUTION if the given equation has no solution \nWrite x0 (2 digits after the decimal point) if the given equation has one solution x0 \nWrite x1 and x2 with x1 < x2 (2 digits after the decimal point) if the given equation has two distinct solutions x1, x2 \n\nExample\nInput \n1 1 8\nOutput \nNO SOLUTION \n\n\nInput \n1 -2 1\nOutput\n1.00\n\nInput \n1 -7 10\nOutput \n2.00 5.00",
            "Code": "function solveQuadraticEquation(input) {\n    let arrayInput = input.split(' ');\n    let a = parseFloat(arrayInput[0]);\n    let b = parseFloat(arrayInput[1]);\n    let c = parseFloat(arrayInput[2]);\n    let delta = b * b - 4 * a * c;\n    if (delta < 0) {\n        return \"NO SOLUTION\";\n    } else if (delta === 0) {\n        let x0 = (-b / (2 * a)).toFixed(2);\n        return x0;\n    } else {\n        let x1 = ((-b - Math.sqrt(delta)) / (2 * a)).toFixed(2);\n        let x2 = ((-b + Math.sqrt(delta)) / (2 * a)).toFixed(2);\n        return x1 + \" \" + x2;\n    }\n}"
        },
        "Bai11": {
            "Problem": "Problem: Week 1 - Basic queries on array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Perform a sequence of queries over this sequence including:\nfind-max: return the maximum element of the given sequence\nfind-min: return the minimum element of the given sequence \nsum: return the sum of the elements of the given sequence \nfind-max-segment i j: return the maximum element of the subsequence from index i to index j (i <= j)\n\nInput\nThe first block contains the information about the given sequence with the following format:\nLine 1: contains a positive integer n (1 <= n <= 10000)\nLine 2: contains n integers a1, a2, ..., an (-1000 <= ai <= 1000)\nThe first block is terminated by a character *\nThe second block contains a sequence of queries defined above, each query is in a line. The second block is terminated a 3 characters ***\n\nOutput\nWrite the result of each query in a corresponding line\n \nExample\nInput\n5\n1 4 3 2 5\n*\nfind-max\nfind-min\nfind-max-segment 1 3\nfind-max-segment 2 5\nsum\n***\n\nOutput\n5\n1\n4\n5\n15",
            "Code": "function queriesOnArray(input) {\n    let inputArray = input.split(\"\\n\");\n    let n = parseInt(inputArray[0]);\n    let arr = inputArray[1].split(\" \").map(Number);\n    let queries = inputArray.slice(3, inputArray.length - 1);\n    let answer = [];\n    for (let query of queries) {\n        let parts = query.split(' ');\n        switch (parts[0]) {\n            case 'find-max':\n                answer.push(Math.max(...arr));\n                break;\n            case 'find-min':\n                answer.push(Math.min(...arr));\n                break;\n            case 'sum':\n                answer.push(arr.reduce((a, b) => a + b, 0));\n                break;\n            case 'find-max-segment':\n                let i = parseInt(parts[1]) - 1;\n                let j = parseInt(parts[2]);\n                answer.push(Math.max(...arr.slice(i, j)));\n                break;\n        }\n    }\n    return answer.join('\\n');\n}"
        },
        "Bai12": {
            "Problem": "Problem: Week 1 - k-Subsequence even\n\nDescription\nGiven a sequence of integers a1, a2, . . ., an. A k-subsequence is define to be a sequence of k consecutive elements: ai, ai+1, . . ., ai+k-1. The weight of a k-subsequence is the sum of its elements.\nGiven positive integers k and m. Compute the number Q of k-subsequences such that the weight is even.\n\nInput\nLine 1: contains 2 positive integers n, k (1 <= n <= 100000, 1 <= k <= n/2)\nLine 2: contains a1, a2, . . ., an. (1 <= ai <= 10000)\nOutput\nWrite the value Q\n\nExample\nInput\n6  3\n2 4 5 1 1 2 \n\nOutput\n2",
            "Code": "function kSubsequenceEven(input) {\n    let inputArray = input.split(\"\\n\");\n    let nk = inputArray[0].split(' ');\n    let n = parseInt(nk[0]);\n    let k = parseInt(nk[1]);\n    let arr = inputArray[1].split(\" \").map(Number);\n    let count = 0;\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += arr[i];\n    }\n    if (sum % 2 == 0) {\n        count++;\n    }\n    \n    for (let i = 0; i < n - k; i++) {\n        sum = sum - arr[i] + arr[i + k];\n    \n        if (sum % 2 == 0) {\n            count++;\n        }\n    }\n    return count;\n}\n"
        },
        "Bai13": {
            "Problem": "Problem: Week 1 - Count words\n\nDescription\nGiven a Text, write a prorgam to count the number Q of words (ignore characters SPACE, TAB, LineBreak) of this Text\n\nInput\nThe Text\n\nOutput\nWrite the number Q of words\n\nExample\nInput\nHanoi University Of Science and Technology\nSchool of Information and Communication Technology\n\n\nOutput\n12",
            "Code": "function countWords(text) {\n    let words = text.replace(/\\s+/g, ' ').trim().split(' ');\n    return words.length;\n}\n"
        },
        "Bai14": {
            "Problem": "Problem: Week 1 - Text Replacement\n\nDescription\nCho v\u0103n b\u1ea3n T v\u00e0 2 m\u1eabu P1, P2 \u0111\u1ec1u l\u00e0 c\u00e1c x\u00e2u k\u00fd t\u1ef1 (kh\u00f4ng ch\u1ee9a k\u00fd t\u1ef1 xu\u1ed1ng d\u00f2ng, \u0111\u1ed9 d\u00e0i kh\u00f4ng v\u01b0\u1ee3t qu\u00e1 1000). H\u00e3y thay th\u1ebf c\u00e1c x\u00e2u P1 trong T b\u1eb1ng x\u00e2u P2.\n\nD\u1eef li\u1ec7u\n\u00b7 D\u00f2ng 1: x\u00e2u P1\n\u00b7 D\u00f2ng 2: x\u00e2u P2\n\u00b7 D\u00f2ng 3: v\u0103n b\u1ea3n T\nK\u1ebft qu\u1ea3:\n\u00b7 Ghi v\u0103n b\u1ea3n T sau khi thay th\u1ebf\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nAI\nArtificial Intelligence\nRecently, AI is a key technology. AI enable efficient operations in many fields.\n\nK\u1ebft qu\u1ea3\nRecently, Artificial Intelligence is a key technology. Artificial Intelligence enable efficient operations in many fields.\n",
            "Code": "function textReplacement(input) {\n    let arrayInput = input.split('\\n');\n    let p1 = arrayInput[0];\n    let p2 = arrayInput[1];\n    let t = arrayInput[2];\n    return t.replace(new RegExp(p1, 'g'), p2);\n}"
        }
    },
    "Tuần 2": {
        "Bai1": {
            "Problem": "Problem: Week 2 - D\u00e3y fibonacci\n\nDescription\nGiven a fibonacci sequence a[0], a[1], a[2], ... in which:  a[0] = 0, a[1] = 1, a[n] = a[n-1] + a[n-2], for all n >= 2\nGiven  positive integer n, compute a[n-1].\n\nInput\nLine 1: contains a positive integer n (2 <= n <= 21)\nOutput\nWrite a[n-1]\n\nExample\nInput\n9\nOutput\n21",
            "Code": "function fibonacci(input) {\n  n = parseInt(input);\n    let a = 0;\n    let b = 1;\n    for (let i = 2; i <= n; i++) {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\nconsole.log(fibonacci(16))"
        },
        "Bai2": {
            "Problem": "Problem: Week 2 - Compute C_k_n\n\nDescription\nGiven two positive integers k and n. Compute C(k,n) which is the number of ways to select k objects from a given set of n objects.\n\nInput\nLine 1: two positive integers k and n (1 <= k,n <= 999)\nOutput\nWrite te value C(k,n) modulo 10\n9\n+7.\n\nExample\nInput\n3  5\nOutput\n10\n",
            "Code": "function computeC_k_n(input) {\n    let [k, n] = input.trim().split(\" \").map(Number);\n    let MOD = 1e9 + 7;\n    let C = Array.from(Array(n+1), () => new Array(k+1).fill(0));\n    for (let i = 0; i <= n; i++) {\n        for (let j = 0; j <= Math.min(i, k); j++) {\n            if (j == 0 || j == i) {\n                C[i][j] = 1;\n            } else {\n                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n            }\n        }\n    }\n\n    return C[n][k];\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 2 - Binary sequence generation\n\nDescription\nGiven an integer n, write a program that generates all the binary sequences of length n in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic ordder, eac sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n011\n100\n101\n110\n111",
            "Code": "function binarySequences(input) {\n  let n = parseInt(input);\n  let result = [];\n  for (let i = 0; i < Math.pow(2, n); i++) {\n    let binary = i.toString(2);\n    while (binary.length < n) {\n      binary = \"0\" + binary;\n    }\n    result.push(binary);\n  }\n  return result.join(\"\\n\");\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 2 - Binary sequences generation without consecutive 11\n\nDescription\nGiven an integer n, write a program that generates all binary sequences without consecutive 11 in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic order, each sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n100\n101",
            "Code": "function binarySequencesWithout11(input) {\n  let n = parseInt(input);\n  let result = [];\n  for (let i = 0; i < Math.pow(2, n); i++) {\n    let binary = i.toString(2);\n    while (binary.length < n) {\n      binary = \"0\" + binary;\n    }\n    if (!binary.includes(\"11\")) {\n      result.push(binary);\n    }\n  }\n  return result.join(\"\\n\");\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 2 - Permutation generation\n\nDescription\nGiven an integer n, write a program to generate all permutations of 1, 2, ..., n in a lexicalgraphic order (elements of a permutation are separated by a SPACE character).\n\nExample\nInput \n3\nOutput\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1 ",
            "Code": "function generatePermutations(input) {\n  let n = parseInt(input);\n  let result = [];\n  let nums = [];\n  for (let i = 1; i <= n; i++) {\n    nums.push(i);\n  }\n  permute(nums, 0, n - 1, result);\n  let answ = [];\n  for (let i = 0; i < result.length; i++) {\n    answ.push(result[i].join(' '));\n  }\n  return answ.join(\"\\n\");\n}\n\nfunction permute(nums, l, r, result) {\n  if (l == r) {\n    result.push(nums.slice());\n  } else {\n    for (let i = l; i <= r; i++) {\n      swap(nums, l, i);\n      permute(nums, l + 1, r, result);\n      swap(nums, l, i);\n    }\n  }\n}\n\nfunction swap(nums, i, j) {\n  let temp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = temp;\n}\n"
        },
        "Bai6": {
            "Problem": "Problem: Week 2 - Count number of sudoku solutions\n\nDescription\nWrite a program to compute the number of sudoku solutions (fill the zero elements of a given partial sudoku table)\nFill numbers from 1, 2, 3, .., 9 to 9 x 9 table so that:\nNumbers of each row are distinct\nNumbers of each column are distinct\nNumbers on each sub-square 3 x 3 are distinct\n\nInput\nEach line i (i = 1, 2, ..., 9) contains elements of the i\nth\n row of the Sudoku table: elements are numbers from 0 to 9 (value 0 means the empty cell of the table)\nOutput\nWrite the number of solutions found\n\nExample\nInput\n0 0 3 4 0 0 0 8 9\n0 0 6 7 8 9 0 2 3\n0 8 0 0 2 3 4 5 6\n0 0 4 0 6 5 0 9 7\n0 6 0 0 9 0 0 1 4\n0 0 7 2 0 4 3 6 5\n0 3 0 6 0 2 0 7 8\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\nOutput\n64",
            "Code": "function countSolutions(input) {\n  let inputArray = input.split('\\n');\n  let partialBoard = [];\n  for (let i = 0; i < inputArray.length; i++) {\n    partialBoard.push(inputArray[i].split(' ').map(Number));\n  }\n  let solutions = 0;\n\n  function solve(board, row, col) {\n    if (row === 9) {\n      solutions++;\n      return;\n    }\n\n    if (col === 9) {\n      solve(board, row + 1, 0);\n      return;\n    }\n\n    if (board[row][col] !== 0) {\n      solve(board, row, col + 1);\n      return;\n    }\n\n    for (let num = 1; num <= 9; num++) {\n      if (isValid(board, row, col, num)) {\n        board[row][col] = num;\n        solve(board, row, col + 1);\n        board[row][col] = 0;\n      }\n    }\n  }\n\n  function isValid(board, row, col, num) {\n    for (let i = 0; i < 9; i++) {\n      if (board[row][i] === num) {\n        return false;\n      }\n      if (board[i][col] === num) {\n        return false;\n      }\n      const subRow = Math.floor(row / 3) * 3 + Math.floor(i / 3);\n      const subCol = Math.floor(col / 3) * 3 + (i % 3);\n      if (board[subRow][subCol] === num) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  solve(partialBoard, 0, 0);\n\n  return solutions;\n}"
        }
    },
    "Tuần 3": {
        "Bai1": {
            "Problem": "Problem: Week 3 - Simulation Stack\n\nDescription\nPerform a sequence of operations over a stack, each element is an integer:\nPUSH v: push a value v into the stack\nPOP: remove an element out of the stack and print this element to stdout (print NULL if the stack is empty)\n\nInput\nEach line contains a command (operration) of type \nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n3\n2\n5",
            "Code": "function simulateStack(input) {\n    const stack = [];\n    const output = [];\n  \n    input.split('\\n').forEach((line) => {\n      const [command, value] = line.split(' ');\n  \n      if (command === 'PUSH') {\n        stack.push(parseInt(value));\n      } else if (command === 'POP') {\n        output.push(stack.pop() || 'NULL');\n      }\n    });\n  \n    return output.join('\\n');\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 3 - Simulation Queue\n\nDescription\nPerform a sequence of operations over a queue, each element is an integer:\nPUSH v: push a value v into the queue\nPOP: remove an element out of the queue and print this element to stdout (print NULL if the queue is empty)\n\nInput\nEach line contains a command (operration) of type\nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n1\n2\n3\n\nInput\nPUSH 1\nPOP\nPOP\nPUSH 4\nPOP\n#\nOutput\n1\nNULL\n4",
            "Code": "function simulationQueue(input) {\n    let queue = [];\n    let output = [];\n    let lines = input.split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        if (line.startsWith(\"PUSH\")) {\n            let value = parseInt(line.split(\" \")[1]);\n            queue.push(value);\n        } else if (line === \"POP\") {\n            let value = queue.shift();\n            if (value === undefined) {\n                output.push(\"NULL\");\n            } else {\n                output.push(value);\n            }\n        } else {\n            break;\n        }\n    }\n    return output.join(\"\\n\");\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 3 - Check Parenthesis\n\nDescription\nGiven a string containing only characters (, ), [, ] {, }. Write a program that checks whether the string is correct in expression.\n\nExample\n ([]{()}()[]): correct\n ([]{()]()[]): incorrect\nInput\nOne line contains the string (the length of the string is less than or equal to $10^6$)One line contains the string (the length of the string is less than or equal to 10\n6\n)\nOutput\nWrite 1 if the sequence is correct, and write 0, otherwise\n\nExample\nInput\n(()[][]{}){}{}[][]({[]()})\nOutput\n1",
            "Code": "function checkParenthesis(input) {\n  const stack = [];\n  const pairs = {\n    '(': ')',\n    '[': ']',\n    '{': '}',\n  };\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n\n    if (pairs[char]) {\n      stack.push(char);\n    } else if (char === ')' || char === ']' || char === '}') {\n      if (pairs[stack.pop()] !== char) {\n        return 0;\n      }\n    }\n  }\n\n  return stack.length === 0 ? 1 : 0;\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 3 - WATER JUGS\n\nDescription\nThere are two jugs, a-litres jug and b-litres jug (a, b are positive integers). There is a pump with unlimited water. Given a positive integer c, how to get exactly c litres.\n\nInput\n   Line 1: contains positive integers a,   b,  c  (1 <= a, b, c <= 900)\nOutput\n  write the number of steps or write -1 (if no solution found)\n\nExample\nInput\n6  8  4\nOutput\n4",
            "Code": "function waterJugs(input) {\n  let inputArray = input.split(' ').map(Number);\n  let a = inputArray[0];\n  let b = inputArray[1];\n  let c = inputArray[2];\n  if (a > b) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nif (c > b)\n    return -1;\n\nif ((c % gcd(b, a)) !== 0)\n    return -1;\n\nreturn Math.min(pour(b, a, c), pour(a, b, c));\n}\n\nfunction gcd(a, b) {\n  if (b === 0)\n      return a;\n  return gcd(b, a % b);\n}\n\nfunction pour(fromJug, toJug, target) {\n  let from = fromJug;\n  let to = 0;\n  let step = 1;\n\n  while (from !== target && to !== target) {\n      let temp = Math.min(from, toJug - to);\n\n      to += temp;\n      from -= temp;\n      step++;\n\n      if (from === target || to === target)\n          break;\n\n      if (from === 0) {\n          from = fromJug;\n          step++;\n      }\n\n      if (to === toJug) {\n          to = 0;\n          step++;\n      }\n  }\n  return step;\n}"
        },
        "Bai5": {
            "Problem": "Problem: Week 3 - Tree manipulation & Traversal\n\nDescription\nM\u1ed7i n\u00fat tr\u00ean c\u00e2y c\u00f3 tr\u01b0\u1eddng id (identifier) l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean (id c\u1ee7a c\u00e1c n\u00fat tr\u00ean c\u00e2y \u0111\u00f4i m\u1ed9t kh\u00e1c nhau)\nTh\u1ef1c hi\u1ec7n 1 chu\u1ed7i c\u00e1c h\u00e0nh \u0111\u1ed9ng sau \u0111\u00e2y bao g\u1ed3m c\u00e1c thao t\u00e1c li\u00ean quan \u0111\u1ebfn x\u00e2y d\u1ef1ng c\u00e2y v\u00e0 duy\u1ec7t c\u00e2y\n\u00b7 MakeRoot u: T\u1ea1o ra n\u00fat g\u1ed1c u c\u1ee7a c\u00e2y\n\u00b7 Insert u v: t\u1ea1o m\u1edbi 1 n\u00fat u v\u00e0 ch\u00e8n v\u00e0o cu\u1ed1i danh s\u00e1ch n\u00fat con c\u1ee7a n\u00fat v (n\u1ebfu n\u00fat c\u00f3 id b\u1eb1ng v kh\u00f4ng t\u1ed3n t\u1ea1i ho\u1eb7c n\u00fat c\u00f3 id b\u1eb1ng u \u0111\u00e3 t\u1ed3n t\u1ea1i th\u00ec kh\u00f4ng ch\u00e8n th\u00eam m\u1edbi)\n\u00b7 PreOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc\n\u00b7 InOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 gi\u1eefa\n\u00b7 PostOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 sau\nD\u1eef li\u1ec7u: bao g\u1ed3m c\u00e1c d\u00f2ng, m\u1ed7i d\u00f2ng l\u00e0 1 trong s\u1ed1 c\u00e1c h\u00e0nh \u0111\u1ed9ng \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf tr\u00ean, d\u00f2ng cu\u1ed1i d\u00f9ng l\u00e0 * (\u0111\u00e1nh d\u1ea5u s\u1ef1 k\u1ebft th\u00fac c\u1ee7a d\u1eef li\u1ec7u).\nK\u1ebft qu\u1ea3: ghi ra tr\u00ean m\u1ed7i d\u00f2ng, th\u1ee9 t\u1ef1 c\u00e1c n\u00fat \u0111\u01b0\u1ee3c th\u0103m trong ph\u00e9p duy\u1ec7t theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc, gi\u1eefa, sau c\u1ee7a c\u00e1c h\u00e0nh \u0111\u1ed9ng PreOrder, InOrder, PostOrder t\u01b0\u01a1ng \u1ee9ng \u0111\u1ecdc \u0111\u01b0\u1ee3c t\u1eeb d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nMakeRoot 10\nInsert 11 10\nInsert 1 10\nInsert 3 10\nInOrder\nInsert 5 11\nInsert 4 11\nInsert 8 3\nPreOrder\nInsert 2 3\nInsert 7 3\nInsert 6 4\nInsert 9 4\nInOrder\nPostOrder\n*\nK\u1ebft qu\u1ea3\n11 10 1 3\n10 11 5 4 1 3 8\n5 11 6 4 9 10 1 8 3 2 7\n5 6 9 4 11 1 8 2 7 3 10",
            "Code": "function treeManipulation(input) {\n  const tree = {};\n  let root = null;\n  let answer = [];\n\n  const makeRoot = (u) => {\n    root = u;\n    tree[root] = { children: [] };\n  };\n\n  const insert = (u, v) => {\n    if (!tree[u]) {\n      tree[u] = { children: [] };\n    }\n    if (!tree[v]) {\n      tree[v] = { children: [] };\n    }\n    if (!tree[u].parent) {\n      tree[u].parent = v;\n      tree[v].children.push(u);\n    }\n  };\n\n  const preOrder = (u) => {\n    let result = u + ' ';\n    if (tree[u].children.length > 0) {\n      for (let i = 0; i < tree[u].children.length; i++) {\n        result += preOrder(tree[u].children[i]);\n      }\n    }\n    return result;\n  };\n\n  const inOrder = (u) => {\n    let result = '';\n    if (tree[u].children.length > 0) {\n      result += inOrder(tree[u].children[0]);\n      result += u + ' ';\n      for (let i = 1; i < tree[u].children.length; i++) {\n        result += inOrder(tree[u].children[i]);\n      }\n    } else {\n      result += u + ' ';\n    }\n    return result;\n  };\n\n  const postOrder = (u) => {\n    let result = '';\n    if (tree[u].children.length > 0) {\n      for (let i = 0; i < tree[u].children.length; i++) {\n        result += postOrder(tree[u].children[i]);\n      }\n      result += u + ' ';\n    } else {\n      result += u + ' ';\n    }\n    return result;\n  };\n\n  const lines = input.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].split(' ');\n    const command = line[0];\n    const u = parseInt(line[1]);\n    const v = parseInt(line[2]);\n    if (command === 'MakeRoot') {\n      makeRoot(u);\n    } else if (command === 'Insert') {\n      insert(u, v);\n    } else if (command === 'PreOrder') {\n      answer.push(preOrder(root));\n    } else if (command === 'InOrder') {\n      answer.push(inOrder(root));\n    } else if (command === 'PostOrder') {\n      answer.push(postOrder(root));\n    }\n  }\n  return answer.join('\\n');\n}"
        },
        "Bai6": {
            "Problem": "Problem: Week 3 - Family Tree\n\nDescription\nGiven a family tree represented by child-parent (c,p) relations in which c is a child of p. Perform queries about the family tree:\ndescendants <name>: return number of descendants of the given <name>\ngeneration <name>: return the number of generations of the descendants of the given <name>\nNote that: the total number of people in the family is less than or equal to 10\n4\n\nInput\nContains two blocks. The first block contains information about child-parent, including lines (terminated by a line containing ***), each line contains: <child> <parent> where <child> is a string represented the name of the child and <parent> is a string represented the name of the parent. The second block contains lines (terminated by a line containing ***), each line contains two string <cmd> and <param> where <cmd> is the command (which can be descendants or generation) and <param> is the given name of the person participating in the  query.\nOutput\nEach line is the result of a corresponding query.\n\nExample\nInput\nPeter Newman\nMichael Thomas\nJohn David\nPaul Mark\nStephan Mark\nPierre Thomas\nMark Newman\nBill David\nDavid Newman\nThomas Mark\n***\ndescendants Newman\ndescendants Mark\ndescendants David\ngeneration Mark\n***\nOutput\n10\n5\n2\n2",
            "Code": "function FamilyTree() {\n    this.tree = {};\n    this.descendants = function(name) {\n        if (!this.tree[name]) {\n            return 0;\n        }\n        let count = 0;\n        for (let i = 0; i < this.tree[name].length; i++) {\n            count += 1 + this.descendants(this.tree[name][i]);\n        }\n        return count;\n    };\n    this.generation = function(name) {\n        if (!this.tree[name]) {\n            return 0;\n        }\n        let maxGeneration = 0;\n        for (let i = 0; i < this.tree[name].length; i++) {\n            maxGeneration = Math.max(maxGeneration, this.generation(this.tree[name][i]));\n        }\n        return maxGeneration + 1;\n    };\n    this.addRelation = function(child, parent) {\n        if (!this.tree[parent]) {\n            this.tree[parent] = [];\n        }\n        this.tree[parent].push(child);\n    };\n}\n\nlet familyTree = new FamilyTree();\n\nfunction family(input) {\n    let answer = [];\n    let lines = input.split(\"\\n\");\n    let i = 0;\n    while (lines[i] !== \"***\") {\n        let [child, parent] = lines[i].split(\" \");\n        familyTree.addRelation(child, parent);\n        i++;\n    }\n    i++;\n    while (i < lines.length && lines[i] !== \"***\") {\n        let [cmd, name] = lines[i].split(\" \");\n        if (cmd === \"descendants\") {\n            answer.push(familyTree.descendants(name));\n        } else if (cmd === \"generation\") {\n            answer.push(familyTree.generation(name));\n        }\n        i++;\n    }\n    return answer.join(\"\\n\");\n}"
        },
        "Bai7": {
            "Problem": "Problem: Week 3 - BST - Insertion and PreOrder Traversal\n\nDescription\nGiven a BST initialized by NULL. Perform a sequence of operations on a BST including:\ninsert k: insert a key k into the BST (do not insert if the key k exists)\nInput\n\u2022Each line contains command under the form: \u201cinsert k\u201d\n\u2022The input is terminated by a line containing #\nOutput\n\u2022Write the sequence of keys of nodes visited by the pre-order traversal (separated by a SPACE character)\n\nExample\nInput\ninsert 20\ninsert 10\ninsert 26\ninsert 7\ninsert 15\ninsert 23\ninsert 30\ninsert 3\ninsert 8\n#\nOutput\n20 10 7 3 8 15 26 23 30\n",
            "Code": "class Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value) {\n    const newNode = new Node(value);\n    if (!this.root) {\n      this.root = newNode;\n      return;\n    }\n    let current = this.root;\n    while (true) {\n      if (value === current.value) {\n        return;\n      }\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return;\n        }\n        current = current.right;\n      }\n    }\n  }\n\n  preOrderTraversal(node = this.root) {\n    if (!node) {\n      return '';\n    }\n    return `${node.value} ${this.preOrderTraversal(node.left)}${this.preOrderTraversal(node.right)}`;\n  }\n}\n\nfunction preOrder(input) {\n  const commands = input.split('\\n');\nfor (let i = 0; i < commands.length; i++) {\n  const command = commands[i];\n  if (command === '#') {\n    break;\n  }\n  const value = parseInt(command.split(' ')[1]);\n  bst.insert(value);\n}\nreturn(bst.preOrderTraversal().trim());\n}\nconsole.log(preOrder(input))"
        },
        "Bai8": {
            "Problem": "Problem: Week 3 - Linked List Manipulation\n\nDescription\nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh th\u1ef1c hi\u1ec7n c\u00f4ng vi\u1ec7c sau:\nX\u00e2y d\u1ef1ng danh s\u00e1ch li\u00ean k\u1ebft v\u1edbi c\u00e1c kh\u00f3a \u0111\u01b0\u1ee3c cung c\u1ea5p ban \u0111\u1ea7u l\u00e0 d\u00e3y a1, a2, \u2026, an, sau \u0111\u00f3 th\u1ef1c hi\u1ec7n c\u00e1c thao t\u00e1c tr\u00ean danh s\u00e1ch bao g\u1ed3m: th\u00eam 1 ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u, v\u00e0o cu\u1ed1i danh s\u00e1ch, ho\u1eb7c v\u00e0o tr\u01b0\u1edbc, v\u00e0o sau 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch, ho\u1eb7c lo\u1ea1i b\u1ecf 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch\n\nInput\nD\u00f2ng 1: ghi s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n (1 <= n <= 1000)\nD\u00f2ng 2: ghi c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng a1, a2, \u2026, an.\nC\u00e1c d\u00f2ng ti\u1ebfp theo l\u1ea7n l\u01b0\u1ee3t l\u00e0 c\u00e1c l\u1ec7nh \u0111\u1ec3 thao t\u00e1c (k\u1ebft th\u00fac b\u1edfi k\u00fd hi\u1ec7u #) v\u1edbi c\u00e1c lo\u1ea1i sau:\naddlast  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o cu\u1ed1i danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddfirst  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o \u0111\u1ea7u danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddafter  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng u v\u00e0o sau ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u ch\u01b0a t\u1ed3n t\u1ea1i)\naddbefore  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng  u v\u00e0o tr\u01b0\u1edbc ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u c\u1ee7a t\u1ed3n t\u1ea1i)\nremove  k: lo\u1ea1i b\u1ecf ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k kh\u1ecfi danh s\u00e1ch\nreverse: \u0111\u1ea3o ng\u01b0\u1ee3c th\u1ee9 t\u1ef1 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a danh s\u00e1ch (kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t m\u1edbi c\u00e1c ph\u1ea7n t\u1eed, ch\u1ec9 \u0111\u01b0\u1ee3c thay \u0111\u1ed5i m\u1ed1i n\u1ed1i li\u00ean k\u1ebft)\nOutput\nGhi ra d\u00e3y kh\u00f3a c\u1ee7a danh s\u00e1ch thu \u0111\u01b0\u1ee3c sau 1 chu\u1ed7i c\u00e1c l\u1ec7nh thao t\u00e1c \u0111\u00e3 cho\n\nExample\nInput\n5\n5 4 3 2 1\naddlast 3\naddlast 10\naddfirst 1\naddafter 10 4\nremove 1\n#\n\nOutput\n5 4 3 2 10 ",
            "Code": "class Node {\n  constructor(value) {\n      this.value = value;\n      this.next = null;\n  }\n}\n\nfunction findNode(head, value) {\n  if (head.value == value) {\n      return head;\n  } else if (head.next == null) {\n      return null;\n  } else {\n      return findNode(head.next, value);\n  }\n}\n\nfunction findNodeBefore(head, value) {\n  if (head.value == value) {\n      return null;\n  } else if (head.next.value == value) {\n      return head;\n  } else if (head.next == null) {\n      return null;\n  } else {\n      return findNodeBefore(head.next, value);\n  }\n}\n\nfunction check(head, value) {\n  if (head.value == value) {\n      return true;\n  } else if (head.next == null) {\n      return false;\n  } else {\n      return check(head.next, value);\n  }\n}\n\nfunction addLast(head, value) {\n  if (check(head, value)) {\n      return head;\n  } else {\n      if (head.next != null) {\n          addLast(head.next, value);\n      } else {\n          head.next = new Node(value);\n      }\n  }\n}\n\nfunction addFirst(head, value) {\n  if (check(head, value)) {\n      return head;\n  } else {\n      let node = new Node(value);\n      node.next = head.next;\n      head.next = node;\n      return head;\n  }\n}\n\nfunction addAfter(head, value, x) {\n  if (head.value == null && head.next == null) {\n      addLast(head, value);\n  } else {\n      let node = findNode(head, x);\n      let newNode = new Node(value);\n      newNode.next = node.next;\n      node.next = newNode;\n  }\n}\n\nfunction addBefore(head, value, x) {\n  if (head.value == null && head.next == null) {\n      addLast(head, value);\n  } else {\n      let newNode = new Node(value);\n      let node = findNodeBefore(head, x);\n      newNode.next = node.next;\n      node.next = newNode;\n  }\n}\n\nfunction remove(head, value) {\n  if (check(head, value)) {\n      let node = findNodeBefore(head, value);\n      node.next = node.next.next;\n  }\n}\n\nfunction reverse(head) {\n  let newHead = new Node(null);\n  while (head.next != null) {\n      newHead = addFirst(newHead, head.next.value);\n      head = head.next;\n  }\n  return newHead;\n}\n\nfunction printList(head) {\n    if (head.next != null) {\n        return head.value + ' ' + printList(head.next);\n    } else {\n        return head.value;\n    }\n}\n\nfunction linkedListManipulation(input) {\n  let inputArray = input.split('\\n');\n  const n = parseInt(inputArray[0]);\n  const arr = inputArray[1].split(' ').map(Number);\n  let head = new Node(null);\n  for (let value of arr) {\n    addLast(head, value);\n  }\n  for (let i = 2; inputArray[i] !== '#'; i++) {\n    let sub = inputArray[i].split(' ');\n    if (sub[0] === 'addlast') {\n      addLast(head, parseInt(sub[1]));\n    } else if (sub[0] === 'addfirst') {\n      head = addFirst(head, parseInt(sub[1]));\n    } else if (sub[0] === 'addafter') {\n      if (check(head, parseInt(sub[1])) == false && check(head, parseInt(sub[2])) == true) {\n        addAfter(head, parseInt(sub[1]), parseInt(sub[2]));\n      } \n    } else if (sub[0] === 'addbefore') {\n      if (check(head, parseInt(sub[1])) == false && check(head, parseInt(sub[2])) == true) {\n        addBefore(head, parseInt(sub[1]), parseInt(sub[2]));\n      }\n    } else if (sub[0] === 'remove') {\n      remove(head, parseInt(sub[1]));\n    } else if (sub[0] == 'reverse') {\n      head = reverse(head);\n    }\n  }\n  return printList(head.next);\n}"
        }
    },
    "Tuần 4": {
        "Bai1": {
            "Problem": "Problem: Week 4 - Store & Search String\n\nDescription\nA database contains a sequence of key k1, k2, ..., kn which are strings (1<=n<=100000). Perform a sequence of actions of two kinds:\n\u00b7 find k: find and return 1 if k exists in the database, and return 0, otherwise\n\u00b7 insert k: insert a key k into the database and return 1 if the insertion is successful (k does not exist in the database) and return 0 if the insertion is failed (k exists in the database)\nNote that the length of any key is greater than 0 and less than or equal to 50.\n\nInput\nTwo blocks of information. The first block contains a key of (k1,k2,...,kn) in each line. The first block is terminated with a line containing *. The second block is a sequence of actions of two finds described above: each line contains 2 string: cmd and k in which cmd = find or insert and k is the key (parameter of the action). The second block is terminated with a line containing ***. Note that the number of actions can be up to 100000.\nOutput\nEach line contains the result (0 or 1) of the corresponding action.\n\nExample\nInput\ncomputer\nuniversity\nschool\ntechnology\nphone\n*\nfind school\nfind book\ninsert book\nfind algorithm\nfind book\ninsert book\n***\nOutput\n1\n0\n1\n0\n1\n0",
            "Code": "function storeSearchString(input) {\n    let inputArray = input.split('\\n');\n    let keys = [];\n    let actions = [];\n    let i = 0\n    for (i; inputArray[i] !== '*'; i++) {\n        keys.push(inputArray[i])\n    }\n    for (i; inputArray[i] !== '***'; i++) {\n        actions.push(inputArray[i])\n    }\n    let db = new Set(keys);\n    let results = [];\n    for (let i = 0; i < actions.length; i++) {\n        let [cmd, key] = actions[i].split(\" \");\n        if (cmd === \"find\") {\n            results.push(db.has(key) ? 1 : 0);\n        } else if (cmd === \"insert\") {\n            let size = db.size;\n            db.add(key);\n            results.push(db.size > size ? 1 : 0);\n        }\n    }\n    return results.join('\\n');\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 4 - Hash Over Strings\n\nDescription\nGiven a string s[1\u2026k] which is a sequence of characters taken from {\u2018a\u2019, . . ., \u2018z\u2019}. Given a positive integer m, the hash code of s is defined by the formula:\nH(s) =  (s[1]*256k-1 + s[2]*256k-2 + . . . + s[k]*2560 ) mod m  (the contant integer m is a parameter)\nGiven a sequence of strings k1, k2, \u2026, kn, compute the corresponding hash codes\n\nInput\nLine 1: n and m (1 <= n,m <= 100000)\nLine i+1 (i = 1,2,\u2026,n): contains the string ki (the length of each string is less than or equal to 200)\nOutput\nEach line contains the corresponding hash code of n given strings\n\nExample\nInput\n4 1000\na\nab\nabc\nabcd\nOutput\n97\n930\n179\n924",
            "Code": "function hash(s, m) {\n  let k = s.length;\n  let h = 0;\n  for (let i = 0; i < k; i++) {\n    h += s.charCodeAt(i) * Math.pow(256, k - i - 1);\n  }\n  return h % m;\n}\nfunction hashOverStrings(input) {\n    let inputArray = input.split('\\n');\n    let nm = inputArray[0].split(' ').map(Number);\n    let n = nm[0];\n    let m = nm[1];\n    let arr = [];\n    for (let i = 1; i < inputArray.length; i++) {\n        arr.push(hash(inputArray[i], m));\n    }\n    return arr.join('\\n');\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 4 - Ki\u1ec3m tra xu\u1ea5t hi\u1ec7n\n\nDescription\nCho d\u00e3y s\u1ed1 nguy\u00ean A1, A2, . . . , An v\u1edbi m\u1ed7i s\u1ed1 nguy\u00ean Ai ki\u1ec3m tra xem c\u00f3 s\u1ed1 Aj n\u00e0o b\u1eb1ng Ai hay kh\u00f4ng v\u1edbi j<i.\n\nInput\nD\u00f2ng \u0111\u1ea7u ch\u1ee9a s\u1ed1 n (1\u2264n\u2264100,000)\nD\u00f2ng hai ch\u1ee9a nn s\u1ed1 nguy\u00ean A1, A2, ..., An (1\u2264Ai\u22641000,000,000)\nOutput\nGhi ra n d\u00f2ng, d\u00f2ng th\u1ee9 i in ra 1 n\u1ebfu t\u1ed3n t\u1ea1i Aj=Ai v\u1edbi j<i, ng\u01b0\u1ee3c l\u1ea1i in ra 0.\n\nExample\ninput\n5\n1 4 3 1 4\noutput\n0\n0\n0\n1\n1",
            "Code": "function checkAppears(input) {\n    let inputArray = input.split('\\n');\n    let n = parseInt(inputArray[0]);\n    let arr = inputArray[1].split(' ').map(Number);\n    let occurrence = new Array(n).fill(0);\n    let set = new Set();\n    for (let i = 0; i < n; i++) {\n        if (set.has(arr[i])) {\n            occurrence[i] = 1;\n        }\n        set.add(arr[i]);\n    }\n    return occurrence.join('\\n');\n}"
        },
        "Bai4": {
            "Problem": "Problem: Week 4 - Sum pair of sequence equal to a number\n\nDescription\nCho d\u00e3y a1, a2, ..., an trong \u0111\u00f3 c\u00e1c ph\u1ea7n t\u1eed \u0111\u00f4i m\u1ed9t kh\u00e1c nhau v\u00e0 1 gi\u00e1 tr\u1ecb nguy\u00ean d\u01b0\u01a1ng M. H\u00e3y \u0111\u1ebfm s\u1ed1 Q c\u00e1c c\u1eb7p (i,j) sao cho 1 <= i < j <= n v\u00e0 ai + aj = M.\n\nD\u1eef li\u1ec7u\nD\u00f2ng 1: ghi n v\u00e0 M (1 <= n, M <= 1000000)\nD\u00f2ng 2: ghi a1, a2, ..., an\nK\u1ebft qu\u1ea3\nGhi ra gi\u00e1 tr\u1ecb Q\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\n5 6\n5 2 1 4 3\nK\u1ebft qu\u1ea3\n2",
            "Code": "function countPairs(input) {\n    let inputArray = input.trim().split('\\n');\n    let [n, M] = inputArray[0].split(' ').map(Number);\n    let arr = inputArray[1].split(' ').map(Number);\n    let count = 0;\n    let map = new Map();\n    for (let i = 0; i < n; i++) {\n        if (map.has(M - arr[i])) {\n            count += map.get(M - arr[i]);\n        }\n        if (map.has(arr[i])) {\n            map.set(arr[i], map.get(arr[i]) + 1);\n        } else {\n            map.set(arr[i], 1);\n        }\n    }\n    return count;\n}"
        }
    },
    "Tuần 5": {
        "Bai1": {
            "Problem": "Problem: Week 5 - Minimum Spanning Tree - Kruskal\n\nDescription\nGiven a undirected connected graph G=(V,E) where V={1,\u2026,N}. Each edge (u,v)\u2208E(u,v)\u2208E has weight w(u,v)w(u,v). Compute minimum spanning tree of G.\n\nInput\nLine 1: N and M (1\u2264N,M\u2264105) in which NN is the number of nodes and MM is the number of edges.\nLine i+1 (i=1,\u2026,M): contains 3 positive integers u, v, and w where w is the weight of edge (u,v)\nOutput\nWrite the weight of the minimum spanning tree found.\n\nExample\nInput\n5 8\n1 2 1\n1 3 4\n1 5 1\n2 4 2\n2 5 1\n3 4 3\n3 5 3\n4 5 2\nOutput\n7",
            "Code": "function kruskal(input) {\n    let inputArray = input.split('\\n');\n    let nm = inputArray[0].split(' ').map(Number);\n    let n = nm[0];\n    let m = nm[1];\n    let edges = [];\n    for (let i = 1; i <= m; i++) {\n        let sub = inputArray[i].split(' ').map(Number);\n        edges.push(sub);\n    }\n    let parent = [];\n    for (let i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    edges.sort((a, b) => a[2] - b[2]);\n    let result = 0;\n    for (let i = 0; i < m; i++) {\n        let [u, v, w] = edges[i];\n        let parentU = find(u);\n        let parentV = find(v);\n        if (parentU !== parentV) {\n            parent[parentU] = parentV;\n            result += w;\n        }\n    }\n    return result;\n    function find(node) {\n        if (parent[node] === node) {\n            return node;\n        }\n        parent[node] = find(parent[node]);\n        return parent[node];\n    }\n}"
        },
        "Bai2": {
            "Problem": "Problem: Week 5 - List order of nodes visited by a DFS\n\nDescription\nGiven a undirected graph =(V,E) in which V = {1,2,..,n} is the set of nodes. Write a program that visit nodes of G by a DFS (consider a lexicorgraphic order of nodes).\n\nInput\nLine 1: contains 2 integers n and m (1 <= n,m <= 100000)\nLine i+1: contains u and v which are two end-points of the ith edge\n\nOutput\nSequence of nodes visited by DFS\n\nExample\nInput\n7 12\n1 2\n1 3\n2 3\n2 4\n2 7\n3 5 \n3 7\n4 5\n4 6\n4 7\n5 6\n5 7 \nOutput\n1 2 3 5 4 6 7",
            "Code": "function DFS(input) {\n    let inputArray = input.split('\\n');\n    let nm = inputArray[0].split(' ').map(Number);\n    let n = nm[0];\n    let m = nm[1];\n    let edges = [];\n    for (let i = 1; i <= m; i++) {\n        let sub = inputArray[i].split(' ').map(Number);\n        edges.push(sub);\n    }\n    let graph = new Map();\n    for (let i = 1; i <= n; i++) {\n        graph.set(i, []);\n    }\n    for (let i = 0; i < m; i++) {\n        let [u, v] = edges[i];\n        graph.get(u).push(v);\n        graph.get(v).push(u);\n    }\n    for (let [key, value] of graph) {\n        value.sort((a, b) => a - b);\n    }\n    let visited = new Set();\n    let result = [];\n    function dfs(node) {\n        visited.add(node);\n        result.push(node);\n        for (let neighbor of graph.get(node)) {\n            if (!visited.has(neighbor)) {\n                dfs(neighbor);\n            }\n        }\n    }\n    dfs(1);\n    return result.join(\" \");\n}\n\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 5 - Sequence of nodes visited by BFS\n\nDescription\nGiven undirected graph G = (V,E) in which V = {1, 2, ..., n} is the set of nodes, and E is the set of m edges.\nWrite a program that computes the sequence of nodes visited using a BFS algorithm (the nodes are considered in a lexicographic order)\n\nInput\nLine 1: contains 2 integers n and m which are the number of nodes and the number of edges\nLine i+1 (i = 1, ..., m): contains 2 positive integers u and v which are the end points of the ith edge\n\nOutput\nWrite the sequence of nodes visited by a BFS procedure (nodes a are separated by a SPACE character)\nExample\n\nInput\n6 7\n2 4\n1 3\n3 4\n5 6\n1 2\n3 5\n2 3\n\nOutput\n1 2 3 4 5 6",
            "Code": "function BFS(input) {\n    var graph = inputToGraph(input);\n    var visited = [];\n    var queue = [1];\n\n    while(queue.length > 0) {\n        var node = queue.shift(); \n        if(!visited.includes(node)) {\n            visited.push(node);\n            var neighbours = graph[node]; \n            neighbours.sort((a, b) => a - b);\n            queue.push(...neighbours);\n        }\n\n        if(queue.length === 0) {\n            for(var i = 1; i <= Object.keys(graph).length; i++) {\n                if(!visited.includes(i)) {\n                    queue.push(i);\n                    break;\n                }\n            }\n        }\n    }\n    return visited.join(\" \");\n}\n\nfunction inputToGraph(input) {\n    var lines = input.split('\\n');\n    var graph = {};\n    for(var i = 1; i < lines.length; i++) {\n        var [u, v] = lines[i].split(' ').map(Number);\n        if(!graph[u]) {\n            graph[u] = [];\n        }\n        if(!graph[v]) {\n            graph[v] = [];\n        }\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    return graph;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 5 - Hamiton Cycle\n\nDescription\nGiven an undirected graph G = (V,E). Write a program to check if G is a Hamiltonian graph.\n\nInput\nLine 1: a positive integer T (number of graphs)\nSubsequent lines are information about T graphs, each has the following format:\nLine 1: n and m (number of nodes and edges)\nLine i+1 (i = 1, 2, ..., m): u and v : two end points of the ith edge\nOutput\nIn the ith line, write 1 if the corresponding is a Hamiltonian graph, and write 0, otherwise\n\nExample\nInput\n2\n5 5\n1 2\n1 3\n2 4\n2 5\n3 5\n7 13\n1 3\n1 5\n1 7\n2 4\n2 5\n2 6\n3 4\n3 5 \n3 7\n4 6\n4 7\n5 7\n6 7\n\nOutput\n0\n1",
            "Code": "function isHamiltonian(n, m, edges) {\n    let graph = new Map();\n    for (let i = 1; i <= n; i++) {\n        graph.set(i, []);\n    }\n    for (let i = 0; i < m; i++) {\n        let [u, v] = edges[i];\n        graph.get(u).push(v);\n        graph.get(v).push(u);\n    }\n    let visited = new Set();\n    let path = [];\n    function dfs(node) {\n        visited.add(node);\n        path.push(node);\n        if (path.length === n) {\n            if (graph.get(node).includes(path[0])) {\n                return true;\n            }\n            path.pop();\n            visited.delete(node);\n            return false;\n        }\n        for (let neighbor of graph.get(node)) {\n            if (!visited.has(neighbor)) {\n                if (dfs(neighbor)) {\n                    return true;\n                }\n            }\n        }\n        path.pop();\n        visited.delete(node);\n        return false;\n    }\n    for (let i = 1; i <= n; i++) {\n        if (dfs(i)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nfunction hamiltonian(input) {\n    let answer = [];\n    let inputArray = input.split('\\n');\n    let t = Number(inputArray[0]);\n    let index = 1;\n    for (let i = 0; i < t; i++) {\n        let [n, m] = inputArray[index++].split(' ').map(Number);\n        let edges = [];\n        for (let j = 0; j < m; j++) {\n            let [u, v] = inputArray[index++].split(' ').map(Number);\n            edges.push([u, v]);\n        }\n        answer.push(isHamiltonian(n, m, edges));\n    }\n    return answer.join('\\n');\n}"
        }
    },
    "Tuần 6": {
        "Bai1": {
            "Problem": "Problem: Week 6 - Max Flow\n\nDescription\nGiven a network G = (V, E) which is a directed weighted graph. Node s is the source and node t is the target. c(u,v) is the capacity of the arc (u,v). Find the maximum flow on G.\nInput\n\u2022Line 1: two positive integers N and M (1 <= N <= 104, 1 <= M <= 106)\n\u2022Line 2: contains 2 positive integers s and t\n\u2022Line i+2 (I = 1,. . ., M): contains two positive integers u and v which are endpoints of ith arc\n\nOutput\n  Write the value of the max-flow found\n\nExample\nInput\n7 12\n6 7\n1 7 7\n2 3 6\n2 5 6\n3 1 6\n3 7 11\n4 1 7\n4 2 4\n4 5 5\n5 1 4\n5 3 4\n6 2 8\n6 4 10\nOutput\n17\n",
            "Code": "function maxFlow(input) {\n  let lines = input.trim().split('\\n');\n  let [N, M] = lines[0].split(' ').map(Number);\n  let [s, t] = lines[1].split(' ').map(Number);\n  let capacity = Array.from({length: N}, () => Array(N).fill(0));\n  for (let i = 2; i < M + 2; i++) {\n      let [u, v, c] = lines[i].split(' ').map(Number);\n      capacity[u - 1][v - 1] = c;\n  }\n  let residual = capacity.map(row => row.slice());\n  let n = residual.length;\n  let maxFlow = 0;\n  let path = bfs(residual, s - 1, t - 1);\n  while (path != null) {\n      let flow = Infinity;\n      for (let i = 0; i < path.length - 1; i++) {\n          let u = path[i], v = path[i + 1];\n          flow = Math.min(flow, residual[u][v]);\n      }\n      maxFlow += flow;\n      for (let i = 0; i < path.length - 1; i++) {\n          let u = path[i], v = path[i + 1];\n          residual[u][v] -= flow;\n          residual[v][u] += flow;\n      }\n      path = bfs(residual, s - 1, t - 1);\n  }\n  return maxFlow;\n}\n\nfunction bfs(residual, source, sink) {\n  let n = residual.length;\n  let pred = Array(n).fill(-1);\n  let queue = [source];\n  pred[source] = source;\n  while (queue.length > 0) {\n      let u = queue.shift();\n      for (let v = 0; v < n; v++) {\n          if (pred[v] == -1 && residual[u][v] > 0) {\n              pred[v] = u;\n              if (v == sink) return getPath(pred, source, sink);\n              queue.push(v);\n          }\n      }\n  }\n  return null;\n}\n\nfunction getPath(pred, source, sink) {\n  let path = [sink];\n  while (path[path.length - 1] != source) {\n      path.push(pred[path[path.length - 1]]);\n  }\n  return path.reverse();\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 6 - Shortest Path between 2 nodes on a directed graph with non-negative weights\n\nDescription\nGiven a directed graph G = (V,E) in which V = {1,2,...,n) is the set of nodes. Each arc (u,v) has a non-negative weight w(u,v). Given two nodes s and t of G. Find the shortest path from s to t on G.\n\nInput\nLine 1: contains two integers n and m which are the number of nodes and the number of arcs of G (1 <= n <= 100000)\nLine i + 1(i = 1,2,...,m): contains 3 integers u, v, w in which w is the weight of arc(u,v) (0 <= w <= 100000)\nLine m+2: contains two integers s and t\n\nOutput\nWrite the weight of the shortest path found or write -1 if no path from s to t was found\n\nExample\nInput\n5 7\n2 5 87\n1 2 97\n4 5 78\n3 1 72\n1 4 19\n2 3 63\n5 1 18\n1 5\n\nOutput\n97",
            "Code": "function shortestPath(n, m, edges, s, t) {\n  const graph = Array.from({ length: n }, () => []);\n  for (let i = 0; i < m; i++) {\n    const [u, v, w] = edges[i];\n    graph[u - 1].push([v - 1, w]);\n  }\n\n  const dist = Array.from({ length: n }, () => Infinity);\n  dist[s - 1] = 0;\n\n  const pq = [[0, s - 1]];\n  while (pq.length) {\n    const [d, u] = pq.shift();\n    if (d > dist[u]) continue;\n    for (const [v, w] of graph[u]) {\n      if (dist[v] > dist[u] + w) {\n        dist[v] = dist[u] + w;\n        pq.push([dist[v], v]);\n      }\n    }\n  }\n\n  return dist[t - 1] === Infinity ? -1 : dist[t - 1];\n}\n\nfunction shortestPathBetween2Nodes(input) {\n  const lines = input.trim().split('\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const edges = lines.slice(1, m + 1).map(line => line.split(' ').map(Number));\n  const [s, t] = lines[m + 1].split(' ').map(Number);\n  return shortestPath(n, m, edges, s, t);\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 6 - All pair shortest paths\n\nDescription\nGiven a directed graph G = (V, E) in which V = {1, 2, ..., n} is the set of nodes, and w(u,v) is the weight (length) of the arc(u,v). Compute d(u,v) - the length of the shortest path from u to v in G, for all u,v in V.\n\nInput\nLine 1: contains 2 positive integers n and m (1 <= n,m <= 10000)\nLine i+1 (i = 1, 2, ..., m): contains 3 positive integers u, v, w in which w is the weight of the arc (u,v) (1 <= w <= 1000)\nOutput\nLine i (i = 1, 2, ..., n): wirte the ith row of the matrix d (if there is not any path from node i to node j, then d(i,j) = -1)\n\nExample\nInput\n4 9 \n1 2 9 \n1 3 7 \n1 4 2 \n2 1 1 \n2 4 5 \n3 4 6 \n3 2 2 \n4 1 5 \n4 2 8\nOutput\n0 9 7 2  \n1 0 8 3  \n3 2 0 5  \n5 8 12 0",
            "Code": "function allPairShortestPaths(n, m, edges) {\n    let answer = [];\n    let dist = [];\n    for (let i = 1; i <= n; i++) {\n        dist[i] = [];\n        for (let j = 1; j <= n; j++) {\n            if (i === j) {\n                dist[i][j] = 0;\n            } else {\n                dist[i][j] = Infinity;\n            }\n        }\n    }\n    for (let i = 0; i < m; i++) {\n        let [u, v, w] = edges[i];\n        dist[u][v] = w;\n    }\n    for (let k = 1; k <= n; k++) {\n        for (let i = 1; i <= n; i++) {\n            for (let j = 1; j <= n; j++) {\n                if (dist[i][k] !== Infinity && dist[k][j] !== Infinity && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    for (let i = 1; i <= n; i++) {\n        sub = dist[i].map(d => d === Infinity ? -1 : d).join(\" \");\n        answer.push(sub);\n    }\n    return answer.join('\\n')\n}\n\nfunction shortestPaths(input) {\n    let inputArray = input.split('\\n');\n    let [n, m] = inputArray[0].split(' ').map(Number);\n    let edges = [];\n    for (let i = 1; i <= m; i++) {\n        let [u, v, w] = inputArray[i].split(' ').map(Number);\n        edges.push([u, v, w]);\n    }\n    return allPairShortestPaths(n, m, edges)\n}\n"
        }
    },
    "Tuần 7": {
        "Bai1": {
            "Problem": "Problem: Week 7 - Bank Transaction\n\nDescription\nThe data about bank transactions consists of a sequence of transactions: the information of each transaction has the following format:\n                                                                    <from_account>  <to_account>   <money>   <time_point>   <atm>\nIn which:\n\u2022\t<from_account>: the account from which money is transferred (which is a string of length from 6 to 20 )\n\u2022\t<to_account>: the account which receives money in the transaction (which is a string of length from 6 to 20)\n\u2022\t<money>: amount of money transferred in the transaction (which is an integer from 1 to 10000)\n\u2022\t<time_point>: the time point at which the transaction is performed, it is a string under the format HH:MM:SS  (hour: minute: second)\n\u2022\t<atm>: the code of the ATM where the transaction is taken (a string of length from 3 to 10)\nExample: T00112233445 T001234002 2000 08:36:25 BIDV (at the ATM BIDV, account T00112233445 transfers 2000$ to account T001234002 at time point 08:36:25 (08 hour, 36 minutes, 25 seconds) \nA transaction cycle of length k starting from account a1 is defined to be a sequence of distinct account a1, a2, \u2026, ak  in which there are transactions from account a1 to a2, from a2 to a3, \u2026, from ak to a1.\nWrite a program that process the following queries: \n?number_transactions: compute the total number of transactions of the data\n?total_money_transaction: compute the total amount of money of transactions  \n?list_sorted_accounts: compute the sequence of bank accounts (including sending and receiving accounts) appearing in the transaction (sorted in an increasing (alphabetical) order)  \n?total_money_transaction_from <account>: compute the total amount of money transferred from the account <account>  \n?inspect_cycle <account> k : return 1 if there is a transaction cycle of length k, starting from <account>, and return 0, otherwise\n\nInput (stdin)\nThe input consists of 2 blocks of information: the data block and the query block\n\u2022\tThe data block consists of lines:\no\tEach line contains the information about a transaction described above\no\tThe data is terminated by a line containing #\n\u2022\tThe query block consists of lines:\no\tEach line is a query described above\no\tThe query block is terminated by a line containing #\n\nOutput (stdout)\n\u2022\tPrint to stdout (in each line) the result of each query described above\n\nExample\nInput\nT000010010 T000010020 1000 10:20:30 ATM1\nT000010010 T000010030 2000 10:02:30 ATM2\nT000010010 T000010040 1500 09:23:30 ATM1\nT000010020 T000010030 3000 08:20:31 ATM1\nT000010030 T000010010 4000 12:40:00 ATM2\nT000010040 T000010010 2000 10:30:00 ATM1\nT000010020 T000010040 3000 08:20:31 ATM1\nT000010040 T000010030 2000 11:30:00 ATM1\nT000010040 T000010030 1000 18:30:00 ATM1\n#\n?number_transactions\n?total_money_transaction\n?list_sorted_accounts\n?total_money_transaction_from T000010010\n?inspect_cycle T000010010 3\n#\nOutput\n9\n19500\nT000010010 T000010020 T000010030 T000010040\n4500\n1",
            "Code": "function processBankTransactions(input) {\n    const data = input.split('\\n');\n    const transactions = [];\n    let i = 0;\n    while (data[i] !== '#') {\n        transactions.push(data[i].split(' '));\n        i++;\n    }\n    i++;\n    const queries = [];\n    while (data[i] !== '#') {\n        queries.push(data[i]);\n        i++;\n    }\n    let result = '';\n    for (const query of queries) {\n        if (query === '?number_transactions') {\n            result += numberTransactions(transactions) + '\\n';\n        } else if (query === '?total_money_transaction') {\n            result += totalMoneyTransaction(transactions) + '\\n';\n        } else if (query === '?list_sorted_accounts') {\n            result += listSortedAccounts(transactions) + '\\n';\n        } else if (query.startsWith('?total_money_transaction_from')) {\n            const account = query.split(' ')[1];\n            result += totalMoneyTransactionFrom(transactions, account) + '\\n';\n        } else if (query.startsWith('?inspect_cycle')) {\n            const [account, k] = query.split(' ').slice(1);\n            result += inspectCycle(transactions, account, parseInt(k)) ? '1\\n' : '0\\n';\n        }\n    }\n    return result;\n}\n\nfunction numberTransactions(transactions) {\n    return transactions.length;\n}\n\nfunction totalMoneyTransaction(transactions) {\n    let total = 0;\n    for (const transaction of transactions) {\n        total += parseInt(transaction[2]);\n    }\n    return total;\n}\n\nfunction listSortedAccounts(transactions) {\n    const accounts = new Set();\n    for (const transaction of transactions) {\n        accounts.add(transaction[0]);\n        accounts.add(transaction[1]);\n    }\n    return [...accounts].sort().join(' ');\n}\n\nfunction totalMoneyTransactionFrom(transactions, account) {\n    let total = 0;\n    for (const transaction of transactions) {\n        if (transaction[0] === account) {\n            total += parseInt(transaction[2]);\n        }\n    }\n    return total;\n}\n\nfunction inspectCycle(transactions, account, k) {\n    const visited = new Set();\n    return dfs(account, account, k, visited, transactions);\n}\n\nfunction dfs(start, current, k, visited, transactions) {\n    if (k === 0) {\n        return start === current;\n    }\n    visited.add(current);\n    for (const transaction of transactions) {\n        if (transaction[0] === current && !visited.has(transaction[1])) {\n            if (dfs(start, transaction[1], k - 1, visited, transactions)) {\n                return true;\n            }\n        }\n    }\n    visited.delete(current);\n    return false;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 7 - Analyze sales order of an e-commerce company\n\nDescription\nData about sales in an e-commerce company (the e-commerce company has several shops) consists a sequence of lines, each line (represents an order) has the following information:\n            <CustomerID> <ProductID> <Price> <ShopID> <TimePoint>\nin which the customer <CustomerID> buys a product <ProductID> with price <Price> at the shop <ShopID> at the time-point <TimePoint>\n<CustomerID>: string of length from 3 to 10\n<ProductID>: string of length from 3 to 10\n<Price>: a positive integer from 1 to 1000\n<ShopID>: string of length from 3 to 10\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n\n\nPerform a sequence of queries of following types:\n?total_number_orders: return the total number of orders\n?total_revenue: return the total revenue the e-commerce company gets\n?revenue_of_shop <ShopID>: return the total revenue the shop <ShopID> gets \n?total_consume_of_customer_shop <CustomerID> <ShopID>: return the total revenue the shop <ShopID> sells products to customer <CustomerID> \n?total_revenue_in_period <from_time> <to_time>: return the total revenue the e-commerce gets of the period from <from_time> to <to_time> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be upto 100000), each line contains the information of a submission with above format \nThe first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be upto 100000), each line is a query described above\nThe second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nC001 P001 10 SHOP001 10:30:10\nC001 P002 30 SHOP001 12:30:10\nC003 P001 40 SHOP002 10:15:20\nC001 P001 80 SHOP002 08:40:10\nC002 P001 130 SHOP001 10:30:10\nC002 P001 160 SHOP003 11:30:20\n#\n?total_number_orders\n?total_revenue\n?revenue_of_shop SHOP001\n?total_consume_of_customer_shop C001 SHOP001 \n?total_revenue_in_period 10:00:00 18:40:45\n#\n\n\nOutput \n6\n450\n170\n40\n370",
            "Code": "function analyzeSalesOrder(input) {\n    const data = input.split('\\n');\n    const orders = [];\n    let i = 0;\n    while (data[i] !== '#') {\n        orders.push(data[i].split(' '));\n        i++;\n    }\n    i++;\n    const queries = [];\n    while (data[i] !== '#') {\n        queries.push(data[i]);\n        i++;\n    }\n    let result = '';\n    for (const query of queries) {\n        if (query === '?total_number_orders') {\n            result += orders.length + '\\n';\n        } else if (query === '?total_revenue') {\n            let total = 0;\n            for (const order of orders) {\n                total += parseInt(order[2]);\n            }\n            result += total + '\\n';\n        } else if (query.startsWith('?revenue_of_shop')) {\n            const shopID = query.split(' ')[1];\n            let total = 0;\n            for (const order of orders) {\n                if (order[3] === shopID) {\n                    total += parseInt(order[2]);\n                }\n            }\n            result += total + '\\n';\n        } else if (query.startsWith('?total_consume_of_customer_shop')) {\n            const [customerID, shopID] = query.split(' ').slice(1);\n            let total = 0;\n            for (const order of orders) {\n                if (order[0] === customerID && order[3] === shopID) {\n                    total += parseInt(order[2]);\n                }\n            }\n            result += total + '\\n';\n        } else if (query.startsWith('?total_revenue_in_period')) {\n            const [fromTime, toTime] = query.split(' ').slice(1);\n            let total = 0;\n            for (const order of orders) {\n                if (order[4] >= fromTime && order[4] <= toTime) {\n                    total += parseInt(order[2]);\n                }\n            }\n            result += total + '\\n';\n        }\n    }\n    return result;\n}\n"
        }
    },
    "Tuần 8": {
        "Bài 1": {
            "Problem": "Problem: Week 8 - Analyze Code Submission of a Programming Contest\n\nDescription\nData about submission of a programming contest consists a sequence of lines, each line has the following information:\n                                                      <UserID> <ProblemID> <TimePoint> <Status> <Point>\nin which the user <UserID> submits his/her code to solve the problem <ProblemID> at time-point <TimePoint>, and gets status <Status> and point <Point>\n<UserID>: string of length from 3 to 10\n<ProblemID>: string under the format Pxy where x, y are digits 0,1,...,9 (for example P03, P10)\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n<Status>: string with two cases (ERR, OK)\n<Point>: integer from {0, 1, 2, ..., 10}\n\nA user can submit the code for solving each problem several time. The point that the user gets for a problem is the maximal point among the submissions for that problem.\n\nPerform a sequence of queries of following types:\n?total_number_submissions: return the number of submissions of the contest\n?number_error_submision: return the number of submissions having status ERR \n?number_error_submision_of_user <UserID>: return the number of submission having status ERR of user <UserID> \n?total_point_of_user <UserID>: return the total point of user <UserID> \n?number_submission_period <from_time_point> <to_time_point>: return the number of submissions in the period from <from_time_point> to <to_time_point> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be up to 100000), each line contains the information of a submission with above format .The first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be up to 100000), each line is a query described above. The second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nU001 P01 10:30:20 ERR 0\nU001 P01 10:35:20 OK 10\nU001 P02 10:40:20 ERR 0\nU001 P02 10:55:20 OK 7\nU002 P01 10:40:20 ERR 0\nU001 P01 11:35:20 OK 8\nU002 P02 10:40:20 OK 10\n#\n?total_number_submissions\n?number_error_submision\n?number_error_submision_of_user U002 \n?total_point_of_user U001 \n?number_submission_period 10:00:00 11:30:45\n#\n\n\nOutput \n7\n3\n1\n17\n6\n",
            "Code": "function programmingContest(input) {\n    const data = input.split('\\n');\n    const submissions = [];\n    let i = 0;\n    while (data[i] !== '#') {\n        submissions.push(data[i].split(' '));\n        i++;\n    }\n    i++;\n    const queries = [];\n    while (data[i] !== '#') {\n        queries.push(data[i]);\n        i++;\n    }\n    let result = '';\n    for (const query of queries) {\n        if (query === '?total_number_submissions') {\n            result += submissions.length + '\\n';\n        } else if (query === '?number_error_submision') {\n            let count = 0;\n            for (const submission of submissions) {\n                if (submission[3] === 'ERR') {\n                    count++;\n                }\n            }\n            result += count + '\\n';\n        } else if (query.startsWith('?number_error_submision_of_user')) {\n            const userID = query.split(' ')[1];\n            let count = 0;\n            for (const submission of submissions) {\n                if (submission[0] === userID && submission[3] === 'ERR') {\n                    count++;\n                }\n            }\n            result += count + '\\n';\n        } else if (query.startsWith('?total_point_of_user')) {\n            const userID = query.split(' ')[1];\n            let total = 0;\n            const maxPoints = {};\n            for (const submission of submissions) {\n                if (submission[0] === userID) {\n                    if (maxPoints[submission[1]] === undefined || maxPoints[submission[1]] < parseInt(submission[4])) {\n                        maxPoints[submission[1]] = parseInt(submission[4]);\n                    }\n                }\n            }\n            for (const problemID in maxPoints) {\n                total += maxPoints[problemID];\n            }            \n            result += total + '\\n';\n        } else if (query.startsWith('?number_submission_period')) {\n            const [fromTime, toTime] = query.split(' ').slice(1);\n            let count = 0;\n            for (const submission of submissions) {\n                if (submission[2] >= fromTime && submission[2] <= toTime) {\n                    count++;\n                }\n            }\n            result += count + '\\n';\n        }\n    }\n    return result;\n}\n"
        },
        "Bài 2": {
            "Problem": "Problem: Week 8 - Citizen Data Analysis\n\nDescription\nCITIZEN\nGiven a DataBase about citizen, perform queries over this DataBase.\nInput\nThe input consists of two blocks: the first block is the DataBase and the second block is the list of queries. Two blocks are separated by a line containing a character *.\n1. The first block (DataBase about citizen) consists of lines (number of lines can be upto 100000), each line is the information about a person and is under the format:\n                                   <code>  <dat_of_birth>  <fathher_code>   <mother_code>  <is_alive>  <region_code>\nin which:\n <code>: the code of the person which is a string of length 7\n <date_of_birth>: the date of birth of the person and has the format YYYY-MM-DD (for example 1980-02-23), <date_of_birth> is before 3000-12-31\n <fathher_code> and <mother_code> is the code of father and mother: they are also strings of length 7. If the code is 0000000, then the current person does not has information about his father or mother\n <is_alive>: a character with two values: \u2018Y\u2019 means that the person is still alive, and \u2018N\u2019 means tat the current person is died.\n <region_code>: the code of the region where the person lives\n\n2. The second block is the list of queries (number of queries can be upto 100000) over the DataBase which consists of following commands:\n NUMBER_PEOPLE: return the number of people (number of lines of the DataBase)\n NUMBER_PEOPLE_BORN_AT <date>: return the number of people having date-of-birth is equal to <date>\n MOST_ALIVE_ANCESTOR <code>: find the most ancestor (farthest in term of generation distance) of the given person <code>. Return the generation distance between the ancestor found and the given person\n NUMBER_PEOPLE_BORN_BETWEEN <from_date> <to_date>: compute the number of people having date-of-birth between <from_date> and <to_date> (<from_date> and <to_date> are under the form YYYY-MM-DD, <to_date> is before 3000-12-31)\n MAX_UNRELATED_PEOPLE: find a subset of people in which two any people of the subset do not have father/mother-children and the size of the subset is maximal. Return the size of the subset found.\nThe second block is terminated by a line containing ***.\nOutput\n Each line presents the result of the corresponding query (described above)\n\nExample\nInput\n0000001 1920-08-10 0000000 0000000 Y 00002\n0000002 1920-11-03 0000000 0000000 Y 00003\n0000003 1948-02-13 0000001 0000002 Y 00005\n0000004 1946-01-16 0000001 0000002 Y 00005\n0000005 1920-11-27 0000000 0000000 Y 00005\n0000006 1920-02-29 0000000 0000000 Y 00004\n0000007 1948-07-18 0000005 0000006 Y 00005\n0000008 1948-07-18 0000005 0000006 Y 00002\n0000009 1920-03-09 0000000 0000000 Y 00005\n0000010 1920-10-16 0000000 0000000 Y 00005\n*\nNUMBER_PEOPLE\nNUMBER_PEOPLE_BORN_AT 1919-12-10\nNUMBER_PEOPLE_BORN_AT 1948-07-18\nMAX_UNRELATED_PEOPLE\nMOST_ALIVE_ANCESTOR 0000008\nMOST_ALIVE_ANCESTOR 0000001\nNUMBER_PEOPLE_BORN_BETWEEN 1900-12-19 1928-11-16\nNUMBER_PEOPLE_BORN_BETWEEN 1944-08-13 1977-12-15\nNUMBER_PEOPLE_BORN_BETWEEN 1987-01-24 1988-06-03\n***\nOutput\n10\n0\n2\n6\n1\n0\n6\n4\n0",
            "Code": "function processCitizenData(input) {\n    let data = input.split('\\n');\n    let people = [];\n    let i = 0;\n    while (data[i] !== '*') {\n        people.push(data[i].split(' '));\n        i++;\n    }\n    i++;\n    let queries = [];\n    while (data[i] !== '***') {\n        queries.push(data[i]);\n        i++;\n    }\n    let result = '';\n    for (let query of queries) {\n        if (query === 'NUMBER_PEOPLE') {\n            result += people.length + '\\n';\n        } else if (query.startsWith('NUMBER_PEOPLE_BORN_AT')) {\n            let date = query.split(' ')[1];\n            let count = 0;\n            for (let person of people) {\n                if (person[1] === date) {\n                    count++;\n                }\n            }\n            result += count + '\\n';\n        } else if (query.startsWith('MOST_ALIVE_ANCESTOR')) {\n            let code = query.split(' ')[1];\n            let person = people.find(p => p[0] === code);\n            let generation = 0;\n            while (person[2] !== '0000000' || person[3] !== '0000000') {\n                generation++;\n                if (person[2] !== '0000000') {\n                    person = people.find(p => p[0] === person[2]);\n                } else {\n                    person = people.find(p => p[0] === person[3]);\n                }\n            }\n            result += generation + '\\n';\n        } else if (query.startsWith('NUMBER_PEOPLE_BORN_BETWEEN')) {\n            let [fromDate, toDate] = query.split(' ').slice(1);\n            let count = 0;\n            for (let person of people) {\n                if (person[1] >= fromDate && person[1] <= toDate) {\n                    count++;\n                }\n            }\n            result += count + '\\n';\n        } else if (query === 'MAX_UNRELATED_PEOPLE') {\n            let peopleWithoutParents = people.filter(p => p[2] === '0000000' && p[3] === '0000000');\n            let graph = {};\n            for (let person of peopleWithoutParents) {\n                graph[person[0]] = [];\n            }\n            for (let person of peopleWithoutParents) {\n                for (let otherPerson of peopleWithoutParents) {\n                    if (person[0] !== otherPerson[0] && person[2] !== otherPerson[0] && person[3] !== otherPerson[0]) {\n                        graph[person[0]].push(otherPerson[0]);\n                    }\n                }\n            }\n            let maxSubsetSize = 0;\n            for (let person of peopleWithoutParents) {\n                let visited = new Set();\n                let queue = [person[0]];\n                let subsetSize = 0;\n                while (queue.length > 0) {\n                    let currentPerson = queue.shift();\n                    if (!visited.has(currentPerson)) {\n                        visited.add(currentPerson);\n                        subsetSize++;\n                        for (let otherPerson of graph[currentPerson]) {\n                            queue.push(otherPerson);\n                        }\n                    }\n                }\n                maxSubsetSize = Math.max(maxSubsetSize, subsetSize);\n            }\n            result += maxSubsetSize + '\\n';\n        }\n    }\n    return result;\n}\n"
        }
    }
}